// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import "mx-global";
import { Big } from "big.js";

// BEGIN EXTRA CODE
import "../shim.js";
import support from"../support/entidad";
// END EXTRA CODE

/**
 * Create connection to mediator and request mediation
 * 
 * Note, connections to the Mediator are created using a public did hosted by the mediator. Using AFJ you can connect to the did, without first receiving an invitation
 * @param {string} agent_key
 * @param {string} mediatorDid - e.g. did:web:ab.cd.id
 * @param {Nanoflow} callback - optional
 * @param {MxObject} userData - optional
 * @returns {Promise.<string>}
 */
export async function jsa_aries_agent_mediator_setupMediationWithDid_2(agent_key, mediatorDid, callback, userData) {
	// BEGIN USER CODE
	try{
		if(agent_key==null)return Promise.reject("Invalid agent_key parameter");										//mandatory
		if(mediatorDid==null)return Promise.reject("Invalid mediatorDid parameter");										//mandatory
		let agent=support.cache.get(agent_key);
		if(agent==null)return Promise.reject("Agent not found in cache");
		const outOfBandRecord=await agent.oob.findByReceivedInvitationId(mediatorDid);
		let[connection]=outOfBandRecord
			?await agent.connections.findAllByOutOfBandId(outOfBandRecord.id)
			:[]
		;
		if (!connection) {
			const routing=await agent.mediationRecipient.getRouting({useDefaultMediator:false});
			agent.config.logger.debug('Routing created',routing);
			//--------------------------------------------------------------------------------
			//execute mendix callback
			//--------------------------------------------------------------------------------
			if(callback!=null){
				const publicKeyBase58=routing.recipientKey.publicKeyBase58;
				let callback_options={};
				callback_options.publicKeyBase58=publicKeyBase58;
				if(userData!=null){
					callback_options.userData=userData;
				}
				await callback(callback_options);
			}
		//--------------------------------------------------------------------------------
		/*
receiveImplicitInvitation(config: ReceiveOutOfBandImplicitInvitationConfig): Promise<{ outOfBandRecord: OutOfBandRecord; connectionRecord?: ConnectionRecord; }>
config for creating and handling invitation


Creates inbound out-of-band record from an implicit invitation, given as a public DID the agent should be capable of resolving. It automatically passes out-of-band invitation for further processing to acceptInvitation method. If you don't want to do that you can set autoAcceptInvitation attribute in config parameter to false and accept the message later by calling acceptInvitation.

It supports both OOB (Aries RFC 0434: Out-of-Band Protocol 1.1) and Connection Invitation (0160: Connection Protocol). Handshake protocol to be used depends on handshakeProtocols (DID Exchange by default)

Agent role: receiver (invitee)

@returns â€” out-of-band record and connection record if one has been created.

export interface ReceiveOutOfBandImplicitInvitationConfig
  extends Omit<BaseReceiveOutOfBandInvitationConfig, 'isImplicit' | 'reuseConnection'> {
  did: string
  handshakeProtocols?: HandshakeProtocol[]
}

interface BaseReceiveOutOfBandInvitationConfig {
  label?: string
  alias?: string
  imageUrl?: string
  autoAcceptInvitation?: boolean
  autoAcceptConnection?: boolean
  reuseConnection?: boolean
  routing?: Routing
  acceptInvitationTimeoutMs?: number
  isImplicit?: boolean
  ourDid?: string
}
		*/
			const{connectionRecord:newConnection}=await agent.oob.receiveImplicitInvitation({
				did:mediatorDid,
				autoAcceptConnection:true,			//stephan
				autoAcceptInvitation:true,			//ockert
				isImplicit:true,					//ockert
				label:"MediatorLabel",				//ockert
				alias:"MediatorAlias",				//ockert
				acceptInvitationTimeoutMs:10000,	//ockert
				routing:routing
			});
			if(!newConnection){
				return Promise.reject('No connection record to provision mediation');
			}
			connection=newConnection;
		}else{
				//connection not null
		}
		const readyConnection=connection.isReady
			?connection
			//returnWhenIsConnected(connectionId: string, options?: { timeoutMs: number; }): Promise<ConnectionRecord>
			:await agent.connections.returnWhenIsConnected(connection.id,{timeoutMs:100000})
		;
		let provisioned=await agent.mediationRecipient.provision(readyConnection);
		return Promise.resolve(JSON.stringify(provisioned));
	}catch(e){
		return Promise.reject(e.toString());
	}
	// END USER CODE
}
