// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import "mx-global";
import { Big } from "big.js";

// BEGIN EXTRA CODE
import "../shim.js";
//import{supportsIncomingMessageType}from"@aries-framework/core/build/utils/messageType";
//import{V1OfferCredentialMessage,V1RequestPresentationMessage}from"@aries-framework/anoncreds";
//import{V2OfferCredentialMessage,V2RequestPresentationMessage}from"@aries-framework/core";
<<<<<<< HEAD

import { supportsIncomingMessageType } from '@credo-ts/core/build/utils/messageType'
import {V1OfferCredentialMessage,V1RequestPresentationMessage} from '@credo-ts/anoncreds'
import {V2OfferCredentialMessage,V2RequestPresentationMessage} from"@credo-ts/core";
=======
>>>>>>> 537af94197e85e7669fbafb86b781b8cedae934f
// END EXTRA CODE

/**
 * supportsIncomingMessageType(incomingMessageType: ParsedMessageType, expectedMessageType: ParsedMessageType, { allowLegacyDidSovPrefixMismatch }?: { allowLegacyDidSovPrefixMismatch?: boolean; }): boolean
 * 
 * Check whether the incoming message type is a message type that can be handled by comparing it to the expected message type. In this case the expected message type is e.g. the type declared on an agent message class, and the incoming message type is the type that is parsed from the incoming JSON.
 * 
 * The method will make sure the following fields are equal:
 * 
 * documentUri
 * protocolName
 * majorVersion
 * messageName
 * If allowLegacyDidSovPrefixMismatch is true (default) it will allow for the case where the incoming message type still has the legacy did:sov:BzCbsNYhMrjHiqZDTUASHg;spec did prefix, but the expected message type does not. This only works for incoming messages with a prefix of did:sov:BzCbsNYhMrjHiqZDTUASHg;spec and the expected message type having a prefix value of https:/didcomm.org
 * 
 * @example
 * 
 * const incomingMessageType = parseMessageType('https://didcomm.org/connections/1.0/request')
 * const expectedMessageType = parseMessageType('https://didcomm.org/connections/1.4/request')
 * 
 * // Returns true because the incoming message type is equal to the expected message type, except for
 * // the minor version, which is lower
 * const isIncomingMessageTypeSupported = supportsIncomingMessageType(incomingMessageType, expectedMessageType)
 * @example
 * 
 * const incomingMessageType = parseMessageType('did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/connections/1.0/request')
 * const expectedMessageType = parseMessageType('https://didcomm.org/connections/1.0/request')
 * 
 * // Returns true because the incoming message type is equal to the expected message type, except for
 * // the legacy did sov prefix.
 * const isIncomingMessageTypeSupported = supportsIncomingMessageType(incomingMessageType, expectedMessageType
 * @param {string} incomingMessageType - json
 * @param {"Agent_SDK.enum_aries_MessageType.V1OfferCredentialMessage"|"Agent_SDK.enum_aries_MessageType.V2OfferCredentialMessage"|"Agent_SDK.enum_aries_MessageType.V1RequestPresentationMessage"|"Agent_SDK.enum_aries_MessageType.V2RequestPresentationMessage"} expectedMessageType
 * @returns {Promise.<boolean>}
 */
export async function jsa_aries_core_build_utils_messageType_supportsIncomingMessageType(incomingMessageType, expectedMessageType) {
	// BEGIN USER CODE
	try{
		if(incomingMessageType==null||incomingMessageType.length==0)return Promise.reject("Invalid incomingMessageType parameter");
		try{
			incomingMessageType=JSON.parse(incomingMessageType);
		}catch(e){
			return Promise.reject("incomingMessageType is not a valid JSON object");
		}
		if(expectedMessageType==null||expectedMessageType.length==0)return Promise.reject("Invalid expectedMessageType parameter");
		console.info("expectedMessageType>"+expectedMessageType);
		switch(expectedMessageType){
			case"V1OfferCredentialMessage":
				expectedMessageType=V1OfferCredentialMessage;
				break;
			case"V1RequestPresentationMessage":
				expectedMessageType=V1RequestPresentationMessage;
				break;
			case"V2OfferCredentialMessage":
				expectedMessageType=V2OfferCredentialMessage;
				break;
			case"V2RequestPresentationMessage":
				expectedMessageType=V2RequestPresentationMessage;
				break;
			default:																															// -
				return Promise.reject("Invalid expectedMessageType parameter");																	// -
				break;																															// -
		}																																		// -
		return Promise.resolve(
			supportsIncomingMessageType(incomingMessageType,expectedMessageType.type)
		);
	}catch(e){
		return Promise.reject(e.toString());
	}
	// END USER CODE
}
